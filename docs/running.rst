.. _compileandrun:

Compile and run a POP-Java application
======================================

This chapter explains the POP-Java compilation process, the POP-Java
application launching process and the tools related to those processes. The
structure of this chapter is as follows: The first section explains the
compilation process and the special compiler for POP-Java. The second describes
the application launching tools. The third one aims to help the programmer to
understand the importance of the object map and the object map generator in the
POP-Java application launching process. Finally, a full example is explained to
pass trough the whole process.


The POP-Java compiler
---------------------

POP-Java has its own compilation process. As POP-Java applications are written
in the POP-Java language, the programmer have to use the POP-Java compiler to
compile its application. The :num:`fig-popjava-compiler` shows the POP-Java
compilation process. The POP-Java source files will be converted in standard
Java source files by a specific parser and code generator. These Java source
files will be compiled with the POP-Java library and produce compiled class
files or a Java archive file (JAR).

.. _fig-popjava-compiler:
.. figure:: images/popjcompiler.png

   POP-Java compilation process

The POP-Java compiler will parse and generate new source file only for the
files with .pjava extension. Due to that, it is very important the main class
and the parallel classes have this extension and not the standard ``.java``
extension.

The POP-Java compiler is accessible trough the command "popjc". The command
syntax is as follow::

  popjc <options> <files>

Options:

* ``-n`` or ``--noclean``: Do not clean the temporary files generated by the
  parser and code generator.
* ``-p`` or ``--popcpp``: Use the specified additional informations XML file
  for the compilation (See :ref:`mixed`).
* ``-j`` or ``--jar``: Compile the source files in a JAR file. Name of the JAR
  must be specified.
* ``-v`` or ``--verbose``: Print additional information during the compilation
  process.
* ``-c`` or ``--classpath``: Add class file or JAR file to the compilation.
* ``-x`` or ``--xmlpopcpp``: Generate the XML additional information file with
  the specified source files (See :ref:`mixed`).
* ``-g`` or ``--generate``: Generate the POP-C++ partial implementation from
  the specified source file (See :ref:`mixed`). Not implemented in the current
  version.

The files in the command line are the ones to compile (``.pjava`` or
``.java``). The command help is available in the appendix :ref:`popjc_help`.


The POP-Java application launcher
---------------------------------

To help POP-Java programmer, POP-Java provide an application launcher that
simplify the launch of a POP-Java application. This application launcher is
named ``popjrun`` and is used with the following syntax::

  popjrun <options> [<objectmap>] <MainClass> <arguments>

Here is an explanation of the arguments to provide to the POP-Java application
launcher:

* ``options``: in the current version there is only one option ``-c`` or
  ``--classpath`` that allow the programmer to add some class path for the
  execution of the POP-Java application. The different class paths must be
  separated with a semicolon.
* ``objectmap``: this informations is not mandatory. If it's provided, the
  object map inform the runtime system about the location of the different
  compiled parallel classes of the application. If it's not provided, the
  default object map (located under:
  ``POPJAVA_LOCATION}/etc/defaultobjectmap.xml``) will be used. More
  information give in :ref:`objectmap`.
* ``MainClass``: this is a main class of the POP-Java application.
* ``arguments``: these are the arguments of the program.


.. _objectmap:

The POP-Java object map and object map generator
------------------------------------------------

The object map is an XML file that informs the POP-C++ runtime about the
location of the different compiled parallel classes of the application. This
file can be given to the "popjrun" tool. If the programmer do not give this
file, the default object map located in ``POPJAVA_LOCATION}/etc/`` will be
used.

The object map can be generated with the POP-Java application launcher. By
using the option ``-l`` or ``--listlong`` and giving the class files or the JAR
file, the object map will be printed to the standard output. The easiest way to
save this file is to redirect the output into the desired file.

Here are the command used for our example:

**Compiled classes**

::

  popjrun --listlong Parclass1.class:Parclass2.class > objectmap.xml

**JAR file**

::

  popjrun --listlong parclasses.jar > objectmap.xml


Full example
------------

This section shows how to write, compile and launch a POP-Java application by
using a simple example. The POP-Java application used in this example includes
only one parallel class. All sources of this example can be found in the
directory ``examples/integer`` from the POP-Java distribution.

Programming
~~~~~~~~~~~

When we start to develop a POP-Java application the main part is the parallel
classes. The following code snippet shows the parallel class implementation:

.. _testintegerclass:
.. code-block:: java
   :linenos:

   @POPClass
   public class Integer {
       private int value;

       @POPObjectDescription(url="localhost")
       public Integer() {
           value = 0;
       }

       @POPSyncConc
       public int get() {
           return value;
       }

       @POPAsyncSeq
       public void set(int val) {
           value = val;
       }

       @POPAsyncMutex
       public void add(Integer i) {
           value += i.get();
       }
   }

As we can see this class use special POP-Java keywords. In the line 1, the
parclass keyword specifies that this class is a parallel class. The constructor
declaration includes an object description (line 4). The method declarations
includes the invocation semantics (line 8, 12 and 16). The method ``add``
(line 16) receive another parallel object as a parameter and it's transparent
for the programmer.

Once the parallel class is implemented, we can write a main class that use this
parallel class. The following code snippet shows the code of the main class:

.. _testintegermain:
.. code-block:: java
   :linenos:

   public TestInteger {
       public static void main(String[] args){
           Integer i1 = new Integer();
           Integer i2 = new Integer();
           i1.set(23);
           i2.set(25);
           System.out.println("i1=" + i1.get());
           System.out.println("i2=" + i2.get());
           i1.add(i2);
           int sum = i1.get();
           System.out.println("i1+i2 = "+sum);
           if(sum==48)
               System.out.println("Test Integer Successful");
           else
               System.out.println("Test Integer failed");
       }
   }


The code of the main class is pure Java code. However, this code must be
declared in a file with ``.pjava`` extension to be considered by the POP-Java
compiler. The instantiation (lines 3-4) and the method calls (lines 5-9) are
transparent for the programmer.


Compiling
~~~~~~~~~

The POP-Java compiler can generate two kind of compiled code. The first is the
standard Java compiled class file (.class). The second is the Java archive
(JAR) file. Here are the two commands to compile the example application.

**Compiling as .class files**

::

   popjc Integer.pjava TestInteger.pjava


**Compiling as a JAR file**

::

   popjc -j myjar.jar Integer.pjava TestInteger.pjava


Create the object map
~~~~~~~~~~~~~~~~~~~~~

Before running the example application, the programmer needs to generate the
object map. The object map will be given to the POP-Java launcher. This file
will inform the POP-C++ runtime system where to find the compiled files. The
POP-Java launcher has a specific option to generate this file from the compiled
files (``.class``) or the JAR file (``.jar``). Here is the command used for our
example::

   popjrun --listlong Integer.class > objmap.xml

The command will generate the XML file and print it on the standard output. To
save this file, we redirect the output in a file named objmap.xml. This file
contains the following XML code (the path specified in the element CodeFile
will be different on your computer):

.. code-block:: xml

   <CodeInfoList>
     <CodeInfo>
       <ObjectName>Integer</ObjectName>
       <CodeFile Type="popjava">
         /home/clementval/pop/popjava-1.0/example/integer/</CodeFile>
       <PlatForm>*-*</PlatForm>
     </CodeInfo>
   </CodeInfoList>


Running
~~~~~~~

Once the POP-Java application is compiled and the object map is generated, the
application can be run. A POP-Java application is a pure Java application at
the end and could be run with the standard java program. In order to make this
running easier for the programmer, POP-Java include an application launcher.
Here are the command to use to run the POP-Java application example:

**POP-Java application compiled as .class files**

::

  popjrun objectmap.xml TestInteger


**POP-Java application compiled as .jar file**

::

  popjrun -c myjar.jar objectmap.xml TestInteger

**Application output**

Here is what we should have as the application output::

  i1=23
  i2=25
  i1+i2=48
  Test Integer Successful

If we have any problems with the compilation or the launching of the
application, please see the chapter :ref:`trouble`.
